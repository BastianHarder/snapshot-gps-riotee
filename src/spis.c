#include "nrf.h"
#include "nrf_gpio.h"
#include "riotee_spis.h"
#include "FreeRTOS.h"
#include "task.h"
#include "runtime.h"
#include "riotee.h"

TEARDOWN_FUN(spis_teardown_ptr);
static unsigned int pin_cs_out;

//This spi slave is used to receive data from a data source that provides continuous data (clk and data signal) and no cs signal
//Therefore the cs signal has to be driven by the spi slave as well

int spis_init(const riotee_spis_cfg_t* cfg)
{
    //External data source only provides clk and data bit. CS signal has to be generated by the receiver itself whenever data shall be recorded
	NRF_SPIS2->PSEL.CSN = cfg->pin_cs_in;
	NRF_SPIS2->PSEL.SCK = cfg->pin_sck;
	NRF_SPIS2->PSEL.MOSI = cfg->pin_mosi;
    pin_cs_out = cfg->pin_cs_out;
	//configure cs output
	nrf_gpio_pin_clear(pin_cs_out);
	nrf_gpio_cfg_output(pin_cs_out);			
    //Define default characters
	NRF_SPIS2->ORC = 0x01;															//Over-read character
    NRF_SPIS2->DEF = 0x99;															//ignored transaction character
	//Define spi mode
    switch (cfg->mode) {
        case SPIS_MODE0_CPOL0_CPHA0:
            NRF_SPIS2->CONFIG =
                (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos);
            break;
        case SPIS_MODE1_CPOL0_CPHA1:
            NRF_SPIS2->CONFIG =
                (SPI_CONFIG_CPHA_Trailing << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveHigh << SPI_CONFIG_CPOL_Pos);
            break;
        case SPIS_MODE2_CPOL1_CPHA0:
            NRF_SPIS2->CONFIG =
                (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveLow << SPI_CONFIG_CPOL_Pos);
            break;
        case SPIS_MODE3_CPOL1_CPHA1:
            NRF_SPIS2->CONFIG =
                (SPI_CONFIG_CPHA_Leading << SPI_CONFIG_CPHA_Pos) | (SPI_CONFIG_CPOL_ActiveLow << SPI_CONFIG_CPOL_Pos);
            break;
    }
    //No need to use the semaphore because the receive events are controlled by the slave (the CS signal is self generated)
    //No Transmit functionality, only receiver
    NRF_SPIS2->TXD.MAXCNT = 0;
    //Enable Interrupts for SPI Slave 2
    __NVIC_EnableIRQ(SPIM2_SPIS2_SPI2_IRQn);

	return 0;
}

//Function that aborts spi transaction to reduce power consumption as soon as possible and notifys rtos that transaction is aborted
static void teardown() {
    //Prevent interrupt when aborting SPI
    NRF_SPIS2->INTENCLR = SPIS_INTENSET_ENDRX_Msk;
    //abort receiving bytes
    nrf_gpio_pin_set(pin_cs_out);
    //Disable SPI Slave 2					
    NRF_SPIS2->ENABLE = (SPIS_ENABLE_ENABLE_Disabled << SPIS_ENABLE_ENABLE_Pos);
    //Set cs pin low to save power
	nrf_gpio_pin_clear(pin_cs_out);
    //Notify RTOS that teardown function is executed and operation is aborted
    xTaskNotifyIndexed(usr_task_handle, 1, EVT_TEARDOWN, eSetValueWithOverwrite);
    //unregister teardown function pointer as the operation aborted
    spis_teardown_ptr = NULL;
}

void SPIM2_SPIS2_SPI2_IRQHandler(void)
{
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;

    if (NRF_SPIS2->EVENTS_ENDRX == 1)
    {
        //abort receiving bytes
	    nrf_gpio_pin_set(pin_cs_out);
        //Clear interrupt flag
        NRF_SPIS2->EVENTS_ENDRX = 0;
        //Generate EVT_SPIS notification to trigger rtos to free blocked task in spis_receive 
        xTaskNotifyIndexedFromISR(usr_task_handle, 1, EVT_SPIS, eSetBits, &xHigherPriorityTaskWoken);
        //unregister teardown function pointer as the operation finished
        spis_teardown_ptr = NULL;
    }
    //Initiate a context switch if the above notification unblocked a higher priority task
    portYIELD_FROM_ISR(xHigherPriorityTaskWoken);
}

int spis_receive(uint8_t *rx_buf, unsigned n_rx)
{
    unsigned long notification_value;

    taskENTER_CRITICAL();
    //Set cs pin high because it should be idle high
	nrf_gpio_pin_set(pin_cs_out);
    riotee_delay_us(1);
    //Enable SPI Slave 2					
	NRF_SPIS2->ENABLE = (SPIS_ENABLE_ENABLE_Enabled << SPIS_ENABLE_ENABLE_Pos);
    //After Enabling a SPI Slave, the semaphore is automatically given to the CPU. It is released now to enable the spi slave to receive data
    NRF_SPIS2->TASKS_RELEASE = (SPIS_TASKS_RELEASE_TASKS_RELEASE_Trigger << SPIS_TASKS_RELEASE_TASKS_RELEASE_Pos);
    //Define how many bytes shall be received
	NRF_SPIS2->RXD.MAXCNT = n_rx;
    //Define where the received data shall be stored
	NRF_SPIS2->RXD.PTR = (uint32_t)rx_buf;
    //Clear all rtos notifications assigned to user task
    xTaskNotifyStateClearIndexed(usr_task_handle, 1);
    //Make sure ENDRX Event is cleared
    NRF_SPIS2->EVENTS_ENDRX = 0;
    //Enable ENDRX interrupt event to interrupt when the expected amount of bytes has been received (rx buffer is filled)
    NRF_SPIS2->INTENSET = SPIS_INTENSET_ENDRX_Msk;

    //Start receiving bytes by clearing CS signal
	nrf_gpio_pin_clear(pin_cs_out);
    //Register teardown function pointer while operation is in progress
    spis_teardown_ptr = teardown;
    taskEXIT_CRITICAL();

    //Block and wait until EVT_SPIS notification (generated in RXEND interrupt function) is received
    xTaskNotifyWaitIndexed(1, 0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);

    if (notification_value != EVT_SPIS)
        return -1;
    
    //Disable SPI Slave 2					
	NRF_SPIS2->ENABLE = (SPIS_ENABLE_ENABLE_Disabled << SPIS_ENABLE_ENABLE_Pos);
    //Set cs pin low to save power
	nrf_gpio_pin_clear(pin_cs_out);

	return 0;
}
